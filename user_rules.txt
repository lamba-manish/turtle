Use uv only for dependency installation:

uv pip install fastapi uvicorn sqlalchemy alembic aiosqlite pydantic python-dotenv

Store:

All config constants (API keys, DB URI, log levels, environment-specific values, etc.) in app/config.py

Use SQLite as the database (app/database/trading_alerts.db)
Manage migrations with Alembic using autogeneration:

alembic revision --autogenerate -m "describe change"
alembic upgrade head


Follow this directory structure:

/app/
  â”œâ”€â”€ config.py
  â”œâ”€â”€ main.py
  â”œâ”€â”€ database/
  â”œâ”€â”€ routers/
  â”œâ”€â”€ schemas/
  â”œâ”€â”€ services/
  â”œâ”€â”€ middleware/
  â””â”€â”€ logs/{YYYY-MM-DD}/
      â”œâ”€â”€ info/
      â”œâ”€â”€ error/
      â””â”€â”€ request/

ðŸ“„ Code Style & Practices

Use Pydantic models for request bodies (schemas/).

Use Annotated from typing and FastAPIâ€™s parameter functions (Query, Path, Body) for all parameters:

from typing import Annotated
from fastapi import Query, Path, Body

All path, query, and body parameters must be annotated explicitly with:

Descriptions (shown in Swagger)

Examples (if applicable)

Enums (to enable dropdowns in Swagger)

âœ… Example:

from enum import Enum
from fastapi import APIRouter, Query
from typing import Annotated

class AlertType(str, Enum):
    price = "price"
    volume = "volume"
    breakout = "breakout"

@router.get("/alerts/")
def get_alerts(
    alert_type: Annotated[
        AlertType,
        Query(description="Type of alert", example="price")
    ],
    limit: Annotated[int, Query(ge=1, le=100, description="Max results to return")] = 10,
):
    ...


All Enums must be subclasses of str + Enum for dropdown behavior in Swagger.

For body parameters:

@router.post("/alerts/")
def create_alert(
    payload: Annotated[CreateAlertSchema, Body(description="Alert details")]
):
    ...

Avoid using unannotated parameters like alert_type: AlertType without Annotated[...].

Swagger UI should reflect:

Dropdowns for enum values

Descriptions for all inputs

Required/optional indicators

Example values (via Pydantic or Query/Path)

Define SQLAlchemy ORM models in models.py and use them with Alembic.

All endpoints must be modularized inside routers/. Avoid putting routes in main.py.

All business logic (e.g., ICICI Breeze API calls, scanning strategies) goes into services/.

Do not hardcode API keys, credentials, or database URIs â€” always use values from config.py.

Keep code clean, Pythonic, type-annotated, and PEP8-compliant. Use docstrings.

ðŸ§¾ Logging Rules

All logs must be written locally in:

app/logs/{YYYY-MM-DD}/[info|error|request]/


Use the middleware system to:

Generate a unique request_id for each incoming request

Log all request/response bodies under request/ folder

Log business and operational info in info/

Log unexpected exceptions in error/

Request ID (request_id) must be present in:

All log entries (info, error, request)

Response headers (for debugging via client)

Exception tracebacks

Log levels (DEBUG, INFO, ERROR) are controlled only from config.py:

LOG_LEVEL = "DEBUG"  # or INFO, WARNING, ERROR

ðŸ§ª Testing & Debugging

Use Swagger UI (/docs) for testing endpoints.

Trace a specific request by looking up the request_id in the logs.

If any API fails or behaves unexpectedly, check:

logs/{date}/request/ for raw request & response

logs/{date}/error/ for full traceback

logs/{date}/info/ for any business context